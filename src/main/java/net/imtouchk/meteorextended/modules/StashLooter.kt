package net.imtouchk.meteorextended.modules

import baritone.api.BaritoneAPI
import baritone.api.pathing.goals.GoalGetToBlock
import meteordevelopment.meteorclient.events.world.TickEvent
import meteordevelopment.meteorclient.settings.BoolSetting
import meteordevelopment.meteorclient.settings.IntSetting
import meteordevelopment.meteorclient.systems.modules.Categories
import meteordevelopment.meteorclient.systems.modules.Module
import meteordevelopment.meteorclient.utils.Utils
import meteordevelopment.meteorclient.utils.world.BlockUtils
import meteordevelopment.orbit.EventHandler
import net.imtouchk.meteorextended.MeteorExtendedAddon
import net.imtouchk.meteorextended.PathUtils
import net.minecraft.block.entity.ChestBlockEntity
import net.minecraft.block.entity.ShulkerBoxBlockEntity
import net.minecraft.item.Item
import net.minecraft.item.Items
import net.minecraft.util.Hand
import net.minecraft.util.hit.BlockHitResult
import net.minecraft.util.math.BlockPos
import net.minecraft.util.math.Direction
import net.minecraft.util.math.Vec3d


class StashLooter : Module(MeteorExtendedAddon.CATEGORY, "Stash Looter", "For the lazy fucks") {
    private val sgGeneral = settings.defaultGroup
    private val cowerIfFound = sgGeneral.add(BoolSetting.Builder()
        .name("cower-if-found")
        .description("Avoid players at all costs (when disabled, they are completely ignored)")
        .defaultValue(true)
        .build()
    )
    private val maxSearchArea = sgGeneral.add(
        IntSetting.Builder()
        .name("max-search-area")
        .description("How far away from spawn should it search")
        .defaultValue(100_000)
        .build()
    )
    private val debugMode = sgGeneral.add(BoolSetting.Builder()
        .name("debug-mode")
        .description("Display additional messages")
        .defaultValue(true)
        .build()
    )

    private val desirableItems = listOf<Item>(Items.SHULKER_BOX)

    private enum class BotState {
        Disabled,
        Roaming,
        Checking,
        Cowering,
    }

    private var currentState = BotState.Disabled
    private var chestsToCheck = mutableListOf<BlockPos>()
    private var checkedChests = mutableListOf<BlockPos>()


    // TODO: Check if this shit actually works lol
    private fun runFromPlayers() {
        val players = mc.player?.clientWorld?.players ?: return
        val botPos = mc.player?.pos ?: return

        val averageDist = Vec3d(0.0, 0.0, 0.0)
        for(player in players) {
            val playerPos = player.pos
            val botPlayerDis = playerPos.subtract(botPos)
            averageDist.add(botPlayerDis)
        }
        averageDist.multiply((1 / players.size).toDouble())

        val bestOpposite = averageDist.negate()
            .normalize()
            .multiply(100.0)

        PathUtils.stopAny()
        val goalProcess = BaritoneAPI.getProvider().primaryBaritone.customGoalProcess
        val goal = GoalGetToBlock(BlockPos(
            (botPos.x + bestOpposite.x).toInt(),
            (botPos.y + bestOpposite.y).toInt(),
            (botPos.z + bestOpposite.z).toInt(),
        ))
        goalProcess.setGoalAndPath(goal)

        currentState = BotState.Cowering
        debugInfo("Current state: COWERING (Destination: ${goal.x}, ${goal.y}, ${goal.z})")
    }

    private fun arePlayersNearby(): Boolean {
        val players = mc.player?.clientWorld?.players
        return players == null || players.size == 0
    }

    private fun lookForNewChests() {
        for(entity in Utils.blockEntities()) {
            if(!(entity is ChestBlockEntity || entity is ShulkerBoxBlockEntity)) continue
            if(checkedChests.contains(entity.pos) || chestsToCheck.contains(entity.pos)) continue
            // TODO : check if chest is generated by world
            chestsToCheck.add(entity.pos)
        }

        debugInfo("Found ${chestsToCheck.size} chests to check.")
    }

    private fun getNearestChest(): BlockPos {
        var nearestChest = chestsToCheck[0]
        for(chest in chestsToCheck) {
            if(distanceToBlock(chest) < distanceToBlock(nearestChest))
                nearestChest = chest
        }
        return nearestChest
    }

    private fun goToNearestChest() {
        val chest = getNearestChest()

        PathUtils.setGoal(chest)
        currentState = BotState.Checking
        debugInfo("Current state: CHECKING. (Destination: ${chest.x}, ${chest.y}, ${chest.z})")
    }

    private fun roam() {
        // TODO: check boundaries

        PathUtils.explore(botPosition())
        currentState = BotState.Roaming
        debugInfo("Current state: ROAMING")
    }

    @EventHandler
    private fun onTick(event: TickEvent.Pre) {
        assert(mc.world != null)

        if(arePlayersNearby() && cowerIfFound.get()) {
            runFromPlayers()
            // TODO: disconnect when safe (option)
            return
        }

        when(currentState) {
            BotState.Disabled -> return
            BotState.Roaming -> {
                if(chestsToCheck.isEmpty())
                    lookForNewChests()
                else
                    goToNearestChest()
            }
            BotState.Checking -> {
                val chest = getNearestChest()
                if (distanceToBlock(chest) <= 5) {
                    val entity = mc.player?.clientWorld?.getBlockEntity(chest)
                    checkedChests.add(chest)
                    chestsToCheck.remove(chest)

                    val chestPos = entity?.pos!!
                    val block = BlockHitResult(
                        Vec3d(chestPos.x.toDouble(), chestPos.y.toDouble(), chestPos.z.toDouble()),
                        Direction.UP,
                        chestPos,
                        false
                    )
                    BlockUtils.interact(block, Hand.MAIN_HAND, true)
                    debugInfo("Checked chest")
                    // roam()
                    currentState = BotState.Disabled
                }
            }
            else -> {}
        }
    }

    override fun onActivate() {
        roam()
    }

    override fun onDeactivate() {
        PathUtils.stopAny()
        currentState = BotState.Disabled
    }

    private fun debugInfo(message: String) {
        if(debugMode.get())
            info(message)
    }

    private fun botPosition(): Vec3d {
        return mc.player?.pos!!
    }

    private fun distanceToBlock(position: BlockPos): Double {
        return botPosition().distanceTo(Vec3d(
            position.x.toDouble(),
            position.y.toDouble(),
            position.z.toDouble()
        ))
    }
}
