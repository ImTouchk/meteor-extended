package net.imtouchk.meteorextended.modules

import baritone.api.BaritoneAPI
import baritone.api.pathing.goals.GoalGetToBlock
import meteordevelopment.meteorclient.events.world.TickEvent
import meteordevelopment.meteorclient.settings.BoolSetting
import meteordevelopment.meteorclient.systems.modules.Categories
import meteordevelopment.meteorclient.systems.modules.Module
import meteordevelopment.meteorclient.utils.Utils
import meteordevelopment.orbit.EventHandler
import net.imtouchk.meteorextended.MeteorExtendedAddon
import net.minecraft.block.entity.ChestBlockEntity
import net.minecraft.block.entity.ShulkerBoxBlockEntity
import net.minecraft.item.Item
import net.minecraft.item.Items
import net.minecraft.util.math.BlockPos
import net.minecraft.util.math.Vec3d


class StashLooter : Module(MeteorExtendedAddon.CATEGORY, "Stash Looter", "For the lazy fucks") {
    private val sgGeneral = settings.defaultGroup
    private val debugMode = sgGeneral.add(BoolSetting.Builder()
        .name("debug-mode")
        .description("Display additional messages")
        .defaultValue(true)
        .build()
    )
    private final val cowerIfFound = sgGeneral.add(BoolSetting.Builder()
        .name("cower-if-found")
        .description("Avoid players at all costs (when disabled, they are completely ignored)")
        .defaultValue(true)
        .build()
    )

    private final val desirableItems = listOf<Item>(Items.SHULKER_BOX)

    private enum class BotState {
        Disabled,
        Roaming,
        Checking,
        Cowering,
    }

    private var currentState = BotState.Disabled
    private var chestsToCheck = mutableListOf<BlockPos>()
    private var checkedChests = mutableListOf<BlockPos>()

    private fun botPosition(): Vec3d {
        return mc.player?.pos!!
    }

    private fun distanceToBlock(position: BlockPos): Double {
        return botPosition().distanceTo(Vec3d(
            position.x.toDouble(),
            position.y.toDouble(),
            position.z.toDouble()
        ))
    }

    private fun setNewGoal(position: BlockPos) {
        stopPathing()
        startPathing(position)
    }

    private fun isCurrentlyPathing(): Boolean {
        val pathingBehavior = BaritoneAPI.getProvider().primaryBaritone.pathingBehavior
        return pathingBehavior.isPathing
    }

    private fun startPathing(position: BlockPos) {
        val goalProcess = BaritoneAPI.getProvider().primaryBaritone.customGoalProcess
        val goal = GoalGetToBlock(position)
        goalProcess.setGoalAndPath(goal)
    }

    private fun stopPathing() {
        val pathingBehavior = BaritoneAPI.getProvider().primaryBaritone.pathingBehavior
        pathingBehavior.cancelEverything()
    }

    private fun roam() {
        stopPathing()
        val currentPosition = mc.player?.pos ?: return
        val exploreProcess = BaritoneAPI.getProvider().primaryBaritone.exploreProcess
        exploreProcess.explore(
            currentPosition.x.toInt(),
            currentPosition.z.toInt()
        )

        currentState = BotState.Roaming
        debugInfo("Current state: ROAMING")
    }

    // TODO: Check if this shit actually works lol
    private fun runFromPlayers() {
        val players = mc.player?.clientWorld?.players ?: return
        val botPos = mc.player?.pos ?: return

        val averageDist = Vec3d(0.0, 0.0, 0.0)
        for(player in players) {
            val playerPos = player.pos
            val botPlayerDis = playerPos.subtract(botPos)
            averageDist.add(botPlayerDis)
        }
        averageDist.multiply((1 / players.size).toDouble())

        val bestOpposite = averageDist.negate()
            .normalize()
            .multiply(100.0)

        stopPathing()
        val goalProcess = BaritoneAPI.getProvider().primaryBaritone.customGoalProcess
        val goal = GoalGetToBlock(BlockPos(
            (botPos.x + bestOpposite.x).toInt(),
            (botPos.y + bestOpposite.y).toInt(),
            (botPos.z + bestOpposite.z).toInt(),
        ))
        goalProcess.setGoalAndPath(goal)

        currentState = BotState.Cowering
        debugInfo("Current state: COWERING (Destination: ${goal.x}, ${goal.y}, ${goal.z})")
    }

    private fun arePlayersNearby(): Boolean {
        val players = mc.player?.clientWorld?.players
        return players == null || players.size == 0
    }

    private fun lookForNewChests() {
        for(entity in Utils.blockEntities()) {
            if(!(entity is ChestBlockEntity || entity is ShulkerBoxBlockEntity)) continue
            if(checkedChests.contains(entity.pos) || chestsToCheck.contains(entity.pos)) continue
            // TODO : check if chest is generated by world
            chestsToCheck.add(entity.pos)
        }

        debugInfo("Found ${chestsToCheck.size} chests to check.")
    }

    private fun getNearestChest(): BlockPos {
        var nearestChest = chestsToCheck[0]
        for(chest in chestsToCheck) {
            if(distanceToBlock(chest) < distanceToBlock(nearestChest))
                nearestChest = chest
        }
        return nearestChest
    }

    private fun goToNearestChest() {
        val chest = getNearestChest()
        setNewGoal(chest)

        currentState = BotState.Checking
        debugInfo("Current state: CHECKING. (Destination: ${chest.x}, ${chest.y}, ${chest.z})")
    }

    private fun debugInfo(message: String) {
        if(debugMode.get())
            info(message)
    }

    @EventHandler
    private fun onTick(event: TickEvent.Pre) {
        assert(mc.world != null)

        if(arePlayersNearby() && cowerIfFound.get()) {
            runFromPlayers()
            // TODO: disconnect when safe (option)
            return
        }

        when(currentState) {
            BotState.Disabled -> return
            BotState.Roaming -> {
                if(chestsToCheck.isEmpty())
                    lookForNewChests()
                else goToNearestChest()
            }
            BotState.Checking -> {
                if (isCurrentlyPathing()) {
                    return
                }

                // TODO: Baritone presumably arrived at destination
                // do a check to confirm it, and if it is true either loot the chest or break the shulker box
                val chest = getNearestChest()
                if (distanceToBlock(chest) <= 5) {
                    val entity = mc.player?.clientWorld?.getBlockEntity(chest)
                    checkedChests.add(chest)
                    chestsToCheck.remove(chest)
                } else {
                    debugInfo("not implemented")
                    currentState = BotState.Disabled
                }

                roam()
            }
            else -> {}
        }
    }

    override fun onActivate() {
        roam()
    }

    override fun onDeactivate() {
        info("Stash Finder disabled.")
        currentState = BotState.Disabled
    }
}
